---
title: "Elan Conversion"
author: "Fafa"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Clean the environment
rm(list = ls())

```

## Working directory

```{r}
# Set the directory to where the R code is located 

setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

```

## Packages needed 

```{r}
# install.packages("tidyverse")
# install.packages("xml2")

library(tidyverse)
library(xml2)

```

## Read Elan files

There may be more than one Elan file in the folder which we want to bring into R. The following lines bring all those elan files into R and assign them to variables with the same name as the files. For instance, the file "sample.elan" will be assigned to the variable "sample".

```{r}

file_names <- list.files("files/", pattern = ".eaf", full.names = TRUE)

data_list <- lapply(file_names, function(x) {
  read_xml(x)
})

names(data_list) <- tools::file_path_sans_ext(basename(file_names))

list2env(data_list, envir = .GlobalEnv)

```


Below is the main function for extracting the required info from the Elan xml elements. The function is called "elan".

```{r}

elan <- function(df){
  annotations <- xml_find_all(df, "//TIER/ANNOTATION/*/ANNOTATION_VALUE") %>% #xml_find_all() search for all instances of the ANNOTATION_VALUE element within the TIER element in the elan file.
    map_df(~{
      parent <- xml_parent(.x) #for finding the parent of each ANNOTATION_VALUE element
      grandparent <- xml_parent(xml_parent(parent)) #for finding the grandparent of each ANNOTATION_VALUE element
      values <- c(xml_attrs(grandparent), xml_attrs(parent), ANNOTATION_VALUE = xml_text(.x)) #xml_attrs() retrievs all the attribute values for parent and grandparent nodes.
      setNames(data.frame(t(values)), names(values)) #The values are then transposed into a data frame using data.frame() and set as column names using the setNames() function. The resulting data frames are then combined into a single data frame using map_df(), with each row representing a unique ANNOTATION_VALUE element and its corresponding parent and grandparent attribute values.
    })
  
}


```


 We remove the data_list df since we don't need it anymore.
 
```{r}

rm(data_list)

```
 
 We want to apply the function to all the objects in our global environment which are of the type xml_document (we also have values, functions and dataframes, and we don't want to apply the function to them). Here's how we only choose the dataframes and nothing else:
 
```{r}
# Get all object names in the environment
all_objects <- ls()

# Get a list of these objects
all_objects_list <- mget(all_objects)

# Identify the XML document and node objects
is_xml_object <- sapply(all_objects_list, function(x) inherits(x, "xml_document") || inherits(x, "xml_node"))

# Filter the list to keep only the XML objects
xml_objects_list <- all_objects_list[is_xml_object]

```
 
 
```{r}
# Apply the elan() function to the list of dataframes using map()
map_list_anno <- map(xml_objects_list, ~elan(.x))

# Rename the annotations dataframes with the format "annotation_original name of the dataframe"
list_renamed_anno <- setNames(map_list_anno, paste0("annotation_", names(xml_objects_list)))

# Assign the new dataframes to the global environment
list2env(list_renamed_anno, globalenv())

```
 
 
Tnen we get the time info

```{r}

#Getting the time info from the elan file. These values will be mapped to the annotation dataframe later.

time <- function(df){
  timeInfo <- xml_find_all(df, "//TIME_ORDER/TIME_SLOT") %>% 
    map_df(~{
      values <- c(xml_attrs(.x))
    })
}

# Apply the elan() function to the list of dataframes using map()
map_list_time <- map(xml_objects_list, ~time(.x))

# Rename the annotations dataframes with the format "annotation_original name of the dataframe"
list_renamed_time <- setNames(map_list_time, paste0("time_", names(xml_objects_list)))

# Assign the new dataframes to the global environment
list2env(list_renamed_time, globalenv())


```


##Working with sample file

```{r}
table(annotation_sample$TIER_ID)

annotation_sample <- annotation_sample %>% 
  mutate(anno_ref_numeric = str_extract(ANNOTATION_REF, "\\d+") %>% 
           as.numeric(.))

shortened_sample <- annotation_sample %>% 
  filter(TIER_ID %in% c("mb@H", "utterance@H", "GRAID@H", "GRAID Qs"))

widened_sample <- shortened_sample %>%
  pivot_wider(names_from = TIER_ID, values_from = ANNOTATION_VALUE)

```


##Writing outcome

```{r}

#Writing the dataframe as a tab-delimited text
write_delim(widened_sample, file = "widened_sample.txt", delim = "\t")



```

